// Match a list of known valid publicKey -> RevAddress pairs to bind them to veriables
match (
    "04f700a417754b775d95421973bdbdadb2d23c8a5af46f1829b1431f5c136e549e8a0d61aa0c793f1a614f8e437711c7758473c6ceb0859ac7e9e07911ca66b5c4".hexToBytes(),
    "11112VYAt8rUGNRRZX3eJdgagaAhtWTK8Js7F7X5iqddMVqyDTtYau",
    "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111".hexToBytes(),
    "1111pdZDG4MZ3eBfaipaD22VXmbFY6PW9ZdGDWdEcXZz4gGxTxgn9",
    "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222".hexToBytes(),
    "11112CXAkc8pV2AMHUSgHGbFkqovgyY9SRja4ZLSpRC9q7qYZx5SVc"
) {
  (
    genesisPubKey,
    genesisRevAddress, // the rev address of a vault instantiated at genesis
    alicePubKey,
    aliceRevAddress, // the rev address of a vault constructed post-genesis
    bobPubKey,
    bobRevAddress // the rev address of a vault constructed post-genesis
  ) => {

    new
      rl(`rho:registry:lookup`),
      RhoSpecCh,
      ListOpsCh,
      getDeployerId(`rho:test:deployerId:make`),
      setup,
      testTransferIn,
      testTransferOut,
      withVaultAndIdentityOf,
      transfer,
      assertBalances
    in {
      rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
      for(@(_, RhoSpec) <- RhoSpecCh) {
        @RhoSpec!("testSuite", *setup,
          [
            ("Transfer from genesis to Alice", *testTransferIn),
            ("Transfer from Alice to genesis", *testTransferOut)
          ])
      } |

      contract setup(_, ret) = {
        new RevVaultCh, MultiSigRevVaultCh in {
          rl!(`rho:rchain:revVault`, *RevVaultCh) |
          rl!(`rho:rchain:multiSigRevVault`, *MultiSigRevVaultCh) |
          for (@(_, RevVault) <- RevVaultCh; @(_, MultiSigRevVault) <- MultiSigRevVaultCh) {
            ret!((RevVault, MultiSigRevVault))
          }
        }
      } |

      contract testTransferIn(rhoSpec, @(RevVault, MultiSigRevVault), ackCh) = {
        new genesisVaultCh, carolUnf, carolAuthCh, carolVaultCh, ret, retOk  in {
          withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
          @MultiSigRevVault!("unforgeableAuthKey", *carolUnf, *carolAuthCh) |
          for (@carolAuth <- carolAuthCh) {
            // Single sig as a special case of multisig.
            @MultiSigRevVault!("create", [], [carolAuth], 1, *carolVaultCh) |
            for (genesisVault, @genesisVaultKey <- genesisVaultCh; @maybeVault <- carolVaultCh) {
              match maybeVault {
                (false, msg) => {
                  rhoSpec!("assert", (false, "==", true), msg, *ackCh)
                }
                (true, (carolMultiSigVault, carolRevAddr, carolRevVault)) => {
                  genesisVault!("transfer", carolRevAddr, 1000, genesisVaultKey, *ret) |
                  rhoSpec!("assert", ((true, Nil), "== <-", *ret), "transfer successful", *ackCh) |
                  assertBalances!(*retOk, [(*genesisVault, 8999000), (carolMultiSigVault, 1000)], *rhoSpec, *ackCh)
                }
              }
            }
          }
        }
      } |

      contract testTransferOut(rhoSpec, @(RevVault, MultiSigRevVault), ackCh) = {
        new genesisVaultCh, carolUnf, carolAuthCh, carolVaultCh, ret1, ret2, retOk in {
          withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
          @MultiSigRevVault!("unforgeableAuthKey", *carolUnf, *carolAuthCh) |
          for (@carolAuth <- carolAuthCh) {
            // Single sig as a special case of multisig.
            @MultiSigRevVault!("create", [], [carolAuth], 1, *carolVaultCh) |
            for (genesisVault, @genesisVaultKey <- genesisVaultCh; @maybeVault <- carolVaultCh) {
              match maybeVault {
                (false, msg) => {
                  rhoSpec!("assert", (false, "==", true), msg, *ackCh)
                }
                (true, (carolMultiSigVault, carolRevAddr, carolRevVault)) => {
                  genesisVault!("transfer", carolRevAddr, 1000, genesisVaultKey, *ret1) |
                  for (@result <- ret1) {
                    match result {
                      (false, msg) => {
                        rhoSpec!("assert", (false, "==", true), msg, *ackCh)
                      }
                      (true, Nil) => {
                        @carolMultiSigVault!("transfer", genesisRevAddress, 500, carolAuth, *ret2) |
                        rhoSpec!("assert", ((true, (false, "done")), "== <-", *ret2), "transfer successful", *ackCh) |
                        assertBalances!(*retOk, [(*genesisVault, 8999500), (carolMultiSigVault, 5000)], *rhoSpec, *ackCh)
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } |

      new RevVaultCh in {
        rl!(`rho:rchain:revVault`, *RevVaultCh) |
        for (@(_, RevVault) <- RevVaultCh) {

          contract withVaultAndIdentityOf(@pubKey, ret) = {
            new RevAddress(`rho:rev:address`), revAddrCh, vaultCh, deployerIdCh, authKeyCh in {
              getDeployerId!("deployerId", pubKey, *deployerIdCh) |
              RevAddress!("fromPublicKey", pubKey, *revAddrCh) |
              for (@revAddr <- revAddrCh) {
                @RevVault!("findOrCreate", revAddr, *vaultCh) |
                for (@(true, vault) <- vaultCh; deployerId <- deployerIdCh) {
                  @RevVault!("deployerAuthKey", *deployerId, *authKeyCh) |
                  for (@authKey <- authKeyCh) {
                    ret!(vault, authKey)
                  }
                }
              }
            }
          }

        }
      } |

      contract transfer(when, vault, @address, @amount, authKey, ret) = {
        for (_ <- when) {
          vault!("transfer", address, amount, *authKey, *ret)
        }
      } |

      rl!(`rho:lang:listOps`, *ListOpsCh) |
      for(@(_, ListOps) <- ListOpsCh) {

        contract assertBalances(when, @balances, rhoSpec, ret) = {
          for (_ <- when) {
            new assertBalance in {
              @ListOps!("foreach", balances, *assertBalance, *ret) |

              contract assertBalance(@(vault, expectedBalance), retCh) = {
                new balanceCh in {
                  @vault!("balance", *balanceCh) |
                  rhoSpec!("assert", (expectedBalance, "== <-", *balanceCh), "balance is as expected", *retCh)
                }
              }
            }
          }
        }

      }
    }
  }
}
