//scalapackage coop.rchain.rholang.rev

//requires RhoSpec
new
  rl(`rho:registry:lookup`), RhoSpecCh,
  revAddress(`rho:rev:address`),
  stdlog(`rho:io:stdlog`),
  setup,
  test_valid_address, test_invalid_address, test_fromPublicKey, test_fromPublicKey_invalid, test_fromDeployerId, test_fromDeployerId_invalid
in {
  rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
  for(@(_, RhoSpec) <- RhoSpecCh) {
    @RhoSpec!("testSuite", *setup,
      [
        ("Validating a valid address returns Nil", *test_valid_address),
        ("Validating a invalid address returns a non-Nil value", *test_invalid_address),
        ("Convert a public key into a RevAddress", *test_fromPublicKey),
        ("Reject an invalid public key", *test_fromPublicKey_invalid),
        ("Convert a deployer id into a RevAddress", *test_fromDeployerId),
        ("Reject an invalid deployer id", *test_fromDeployerId_invalid),
      ])
  } |

  contract setup(returnCh) = {
    returnCh!([])
  } |

  contract test_invalid_address(rhoSpec, _, ackCh) = {
    new retCh in {
      revAddress!("validate", "some_obviously_invalid_address", *retCh) |
      rhoSpec!("assert", (Nil, "!= <-", *retCh), "Expecting a non-Nil value containing the error message", *ackCh)
    }
  } |

  contract test_valid_address(rhoSpec, _, ackCh) = {
    new retCh in {
      revAddress!("validate", "1111K9MczqzZrNkUNmNGrNFyz7F7LiCUgaCHXd28g2k5PxiaNuCAi", *retCh) |
      rhoSpec!("assert", (Nil, "== <-", *retCh), "expecting a Nil value since there are no errors", *ackCh)
    }
  } |

  contract test_fromPublicKey(rhoSpec, _, ackCh) = {
    new r1, r2, r3 in {
      revAddress!(
        "fromPublicKey",
        "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".hexToBytes(),
        *r1
      ) |
      revAddress!(
        "fromPublicKey",
        "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111".hexToBytes(),
        *r2
      ) |
      revAddress!(
        "fromPublicKey",
        "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222".hexToBytes(),
        *r3
      ) |
      rhoSpec!("assertMany", [
        (("1111WPpi6SB8FpNMtC9drZg3R8T1fH2BVyT52xPUXBbdKDfmskG1r", "== <-", *r1), "correct RevAddress"),
        (("1111pdZDG4MZ3eBfaipaD22VXmbFY6PW9ZdGDWdEcXZz4gGxTxgn9", "== <-", *r2), "correct RevAddress"),
        (("11112CXAkc8pV2AMHUSgHGbFkqovgyY9SRja4ZLSpRC9q7qYZx5SVc", "== <-", *r3), "correct RevAddress"),
     ], *ackCh)
    }
  } |

  contract test_fromPublicKey_invalid(rhoSpec, _, ackCh) = {
    new retCh in {
      revAddress!("fromPublicKey", "F0F0".hexToBytes(), *retCh) |
      rhoSpec!("assert", (Nil, "== <-", *retCh), "correct RevAddress", *ackCh)
    }
  } |

  contract test_fromDeployerId(rhoSpec, _, ackCh) = {
    new r1, r2, r3, getDeployerId(`rho:test:deployerId:get`), deployerIdCh1, deployerIdCh2, deployerIdCh3 in {
      getDeployerId!(
        "deployerId",
        "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".hexToBytes(),
        *deployerIdCh1
      ) |
      getDeployerId!(
        "deployerId",
        "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111".hexToBytes(),
        *deployerIdCh2
      ) |
      getDeployerId!(
        "deployerId",
        "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222".hexToBytes(),
        *deployerIdCh3
      ) |
      for(@deployerId1 <- deployerIdCh1; @deployerId2 <- deployerIdCh2; @deployerId3 <- deployerIdCh3) {
        revAddress!(
          "fromDeployerId",
          deployerId1,
          *r1
        ) |
        revAddress!(
          "fromDeployerId",
          deployerId2,
          *r2
        ) |
        revAddress!(
          "fromDeployerId",
          deployerId3,
          *r3
        ) |
        rhoSpec!("assertMany", [
          (("11112c4Z48VufA19YCWdUoXrXKKVza16dix2xUa5q3TpnRLcZAQg7d", "== <-", *r1), "correct RevAddress"),
          (("1111vQiDiLGjHgjV1D7j6EbXHyStToU3iQ3eWA394p3rzYFocXGtv", "== <-", *r2), "correct RevAddress"),
          (("11112nT39uWFt9J3CT7hi87JRmnWsQuMh1oDjfhkyfcGnjV54Umn1n", "== <-", *r3), "correct RevAddress"),
        ], *ackCh)
      }
    }
  } |

  contract test_fromDeployerId_invalid(rhoSpec, _, ackCh) = {
    new retCh, getDeployerId(`rho:test:deployerId:get`), deployerIdCh in {
      getDeployerId!("deployerId", "F0F0".hexToBytes(), *deployerIdCh) |
      for(@deployerId <- deployerIdCh) {
        revAddress!("fromDeployerId", deployerId, *retCh) |
        rhoSpec!("assert", (Nil, "== <-", *retCh), "correct RevAddress", *ackCh)
      }
    }
  }
}
