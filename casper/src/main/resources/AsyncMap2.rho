//  Rholang map: speedy insert & lookup, no conflicts on lookup, no conflicts on inserts to different keys

new AsyncMap, o(`rho:io:stdout`) in {
  new MakeCell, ByteToBitList, ByteArrayToBitList in {
    contract MakeCell(@val, cell) = {
      for (@cmd, @args <- cell) {
        match cmd {
          "get" => {
            match args {
              [ret] => {
                @ret!(val) |
                MakeCell!(val, *cell)
              }
              x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 14", x]) }
            }
          }
          "set" => {
            match args {
              [newVal, ret] => {
                @ret!(Nil) |
                MakeCell!(newVal, *cell)
              }
              x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 23", x]) }
            }
          }
          "die" => { Nil }
          x => { o!(["ERROR: MATCH FAIL. MakeCell line 27", x]) }
        }
      }
    } |
  
    // Little endian
    contract ByteToBitList(@byte, ret) = {
      ret!([
        byte % 2,
        (byte / 2) % 2,
        (byte / 4) % 2,
        (byte / 8) % 2,
        (byte / 16) % 2,
        (byte / 32) % 2,
        (byte / 64) % 2,
        (byte / 128) % 2
      ])
    } |
  
    contract ByteArrayToBitList(@ba, ret) = {
      new loop in {
        match {
          for (@n, @len, @acc, @P <- loop) {
            if (n == len) {
              ret!(acc)
            } else {
              new bitListCh in {
                ByteToBitList!(ba.nth(n), *bitListCh) |
                for (@bitList <- bitListCh) {
                  P | loop!(n+1, len, acc ++ bitList, P)
                }
              }
            }
          }
        } {
          P => { P | loop!(0, ba.length(), [], P) }
        }
      }
    } |

    contract AsyncMap(@"init", ret) = {
      new map in {
        MakeCell!(0, [*map, []]) |
        ret!(*map)
      }
    } |

    contract AsyncMap(@"get", @map, @key, ret) = {
      new hashCh, bitListCh in {
        // Hash the key to get a 256-bit array
        @"keccak256Hash"!(key.toByteArray(), *hashCh) |
        for (@hash <- hashCh) {
          // Get the bit list
          ByteArrayToBitList!(hash, *bitListCh) |
          for (@bitList <- bitListCh) {
            new loop in {
              match {
                for (@n, @len, @P <- loop) {
                  // Look up the value of the cell at [map, bitList.slice(0, n + 1)]
                  new valCh in {
                    @[map, bitList.slice(0, n)]!("get", [*valCh]) |
                    for (@val <- valCh) {
                      if (n == len) {
                        // If we're at the end of the path, return.
                        ret!(val)
                      } else {
                        // Otherwise check if the rest of the path exists.
                        // Bit k set means cell k exists.
                        if (bitList.nth(n) == 0) {
                          if (val % 2 == 0) {
                            // Cell 0 missing
                            ret!([])
                          } else {
                            // Cell 0 exists
                            P | loop!(n + 1, len, P)
                          }
                        } else {
                          if (val / 2 == 0) {
                            // Cell 1 missing
                            ret!([])
                          } else {
                            // Cell 1 exists
                            P | loop!(n + 1, len, P)
                          }
                        }
                      }
                    }
                  }
                }
              } {
                // TODO: set to 256
                P => { P | loop!(0, 256, P) }
              }
            }
          }
        }
      }
    } |
  
    contract AsyncMap(@"set", @map, @key, @newVal, ret) = {
      new hashCh, bitListCh in {
        o!(["Hashing ", key]) |
        // Hash the key to get a 256-bit array
        @"keccak256Hash"!(key.toByteArray(), *hashCh) |
        for (@hash <- hashCh) {
          o!(["Got hash, converting to bits ", hash]) |
          // Get the bit list
          ByteArrayToBitList!(hash, *bitListCh) |
          for (@bitList <- bitListCh) {
            o!(["Converted to bits, starting loop", bitList]) |
            new loop in {
              match {
                for (@n, @len, @P <- loop) {
                  o!(["In loop: ", n, len]) |
                  // Look up the value of the cell at [map, bitList.slice(0, n + 1)
                  new valCh in {
                    o!(["Getting slice", bitList.slice(0, n)]) |
                    @[map, bitList.slice(0, n)]!("get", [*valCh]) |
                    for (@val <- valCh) {
                      o!(["Got val ", val]) |
                      if (n == len) {
                        // If we're at the end of the path, set the cell to newVal.
                        // TODO: remove the slice once done testing
                        o!(["Setting final cell to ", [newVal]]) |
                        @[map, bitList.slice(0, n)]!("set", [[newVal], *ret])
                      } else {
                        // Otherwise make the rest of the path exist.
                        // Bit k set means cell k exists.
                        o!(["bitList.nth()", n, bitList.nth(n)]) |
                        if (bitList.nth(n) == 0) {
                          match { val % 2 } {
                            // Cell 0 missing
                            0 => {
                              // Create cell, set cell to 0
                              MakeCell!(0, [map, bitList.slice(0, n + 1)]) |
                              new ack in {
                                // set current cell to val | 1 = val + 1 because val&1=0, loop
                                @[map, bitList.slice(0, n)]!("set", [val + 1, *ack]) |
                                for (_ <- ack) {
                                  P | loop!(n + 1, len, P)
                                }
                              }
                            }
                            // Cell 0 exists, loop
                            1 => { P | loop!(n + 1, len, P) }
                          }
                        } else {
                          match { val / 2 } {
                            // Cell 1 missing
                            0 => {
                              o!(["val / 2, 0.  Setting slice to 0", bitList.slice(0, n + 1)]) |
                              // Create cell, set cell to 0
                              MakeCell!(0, [map, bitList.slice(0, n + 1)]) |
                              new ack in {
                                // set current cell to val | 2 = val + 2 because val&2=0, loop
                                @[map, bitList.slice(0, n)]!("set", [val + 2, *ack]) |
                                for (_ <- ack) {
                                  P | loop!(n + 1, len, P)
                                }
                              }
                            }
                            // Cell 1 exists, loop
                            1 => { P | loop!(n + 1, len, P) }
                          }
                        }
                      }
                    }
                  }
                }
              } {
                // TODO: set to 256
                P => { P | loop!(0, 256, P) }
              }
            }
          }
        }
      }
    } |
    
    // Usage
    new o(`rho:io:stdout`), mapCh in {
      o!("Initializing map") |
      AsyncMap!("init", *mapCh) |
      for (@map <- mapCh) {
        o!("Map initialized, setting") |
        new ret in {
          AsyncMap!("set", map, "some key", "some val", *ret) |
          for (_ <- ret) {
            o!("Value set, getting") |
            AsyncMap!("get", map, "some key", *ret) |
            for (@val <- ret) {
              o!(["Got this from the map: ", val])
            }
          }
        }
      }
    }
  }
}