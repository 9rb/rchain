//  Rholang map: speedy insert & lookup, no conflicts on lookup, no conflicts on inserts to different keys

new AsyncMap, o(`rho:io:stdout`) in {
  new MakeCell, ByteToBitList, ByteArrayToBitList, AsyncMapSetter, AsyncMapGetter in {
    contract MakeCell(@val, cell) = {
      for (@cmd, @args <- cell) {
        match cmd {
          "get" => {
            match args {
              [ret] => {
                @ret!(val) |
                MakeCell!(val, *cell)
              }
              x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 14", x]) }
            }
          }
          "set" => {
            match args {
              [newVal, ret] => {
                @ret!(Nil) |
                MakeCell!(newVal, *cell)
              }
              x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 23", x]) }
            }
          }
          "die" => { Nil }
          x => { o!(["ERROR: MATCH FAIL. MakeCell line 27", x]) }
        }
      }
    } |
  
    // Little endian
    contract ByteToBitList(@byte, ret) = {
      ret!([
        byte % 2,
        (byte / 2) % 2,
        (byte / 4) % 2,
        (byte / 8) % 2,
        (byte / 16) % 2,
        (byte / 32) % 2,
        (byte / 64) % 2,
        (byte / 128) % 2
      ])
    } |
  
    contract ByteArrayToBitList(@ba, @n, @len, @acc, ret) = {
      if (n == len) {
        ret!(acc)
      } else {
        new bitListCh in {
          ByteToBitList!(ba.nth(n), *bitListCh) |
          for (@bitList <- bitListCh) {
            ByteArrayToBitList!(ba, n+1, len, acc ++ bitList, *ret)
          }
        }
      }
    } |

    contract AsyncMap(@"init", ret) = {
      new map in {
        MakeCell!(0, [*map, []]) |
        ret!(*map)
      }
    } |
    
    contract AsyncMapGetter(@map, @bitList, @n, @len, ret) = {
      o!(["In getter: ", bitList, n, len]) |
      // Look up the value of the cell at [map, bitList.slice(0, n + 1)]
      new valCh in {
        o!(["Getting from ", bitList.slice(0, n)]) |
        @[map, bitList.slice(0, n)]!("get", [*valCh]) |
        for (@val <- valCh) {
          o!(["Got ", val]) |
          if (n == len) {
            o!(["n == len, returning ", val]) |
            // If we're at the end of the path, return.
            ret!(val)
          } else {
            o!(["bitList.nth(n) = ", bitList.nth(n)]) |
            // Otherwise check if the rest of the path exists.
            // Bit k set means cell k exists.
            if (bitList.nth(n) == 0) {
              if (val % 2 == 0) {
                o!(["val % 2 == 0"]) |
                // Cell 0 missing
                ret!([])
              } else {
                o!(["val % 2 == 1, recursing"]) |
                // Cell 0 exists
                AsyncMapGetter!(map, bitList, n + 1, len, *ret)
              }
            } else {
              if (val / 2 == 0) {
                o!(["val / 2 == 0"]) |
                // Cell 1 missing
                ret!([])
              } else {
                o!(["val / 2 == 1, recursing"]) |
                // Cell 1 exists
                AsyncMapGetter!(map, bitList, n + 1, len, *ret)
              }
            }
          }
        }
      }
    } |

    contract AsyncMap(@"get", @map, @key, ret) = {
      new hashCh, bitListCh in {
        // Hash the key to get a 256-bit array
        @"keccak256Hash"!(key.toByteArray(), *hashCh) |
        for (@hash <- hashCh) {
          // Get the bit list
          ByteArrayToBitList!(hash, 0, hash.length(), [], *bitListCh) |
          for (@bitList <- bitListCh) {
            AsyncMapGetter!(map, bitList, 0, 256, *ret)
          }
        }
      }
    } |

    contract AsyncMapSetter(@map, @bitList, @n, @len, @newVal, ret) = {
      o!(["In loop: ", n, len]) |
      // Look up the value of the cell at [map, bitList.slice(0, n + 1)
      new valCh in {
        o!(["Getting slice", bitList.slice(0, n)]) |
        @[map, bitList.slice(0, n)]!("get", [*valCh]) |
        for (@val <- valCh) {
          o!(["Got val ", val]) |
          if (n == len) {
            // If we're at the end of the path, set the cell to newVal.
            // TODO: remove the slice once done testing
            o!(["Setting final cell to ", [newVal]]) |
            @[map, bitList.slice(0, n)]!("set", [[newVal], *ret])
          } else {
            // Otherwise make the rest of the path exist.
            // Bit k set means cell k exists.
            o!(["bitList.nth()", n, bitList.nth(n)]) |
            if (bitList.nth(n) == 0) {
              match { val % 2 } {
                // Cell 0 missing
                0 => {
                  // Create cell, set cell to 0
                  MakeCell!(0, [map, bitList.slice(0, n + 1)]) |
                  new ack in {
                    // set current cell to val | 1 = val + 1 because val&1=0, loop
                    @[map, bitList.slice(0, n)]!("set", [val + 1, *ack]) |
                    for (_ <- ack) {
                      AsyncMapSetter!(map, bitList, n + 1, len, newVal, *ret)
                    }
                  }
                }
                // Cell 0 exists, loop
                1 => { AsyncMapSetter!(map, bitList, n + 1, len, newVal, *ret) }
              }
            } else {
              match { val / 2 } {
                // Cell 1 missing
                0 => {
                  o!(["val / 2, 0.  Setting slice to 0", bitList.slice(0, n + 1)]) |
                  // Create cell, set cell to 0
                  MakeCell!(0, [map, bitList.slice(0, n + 1)]) |
                  new ack in {
                    // set current cell to val | 2 = val + 2 because val&2=0, loop
                    @[map, bitList.slice(0, n)]!("set", [val + 2, *ack]) |
                    for (_ <- ack) {
                      AsyncMapSetter!(map, bitList, n + 1, len, newVal, *ret)
                    }
                  }
                }
                // Cell 1 exists, loop
                1 => { AsyncMapSetter!(map, bitList, n + 1, len, newVal, *ret) }
              }
            }
          }
        }
      }
    } |
  
    contract AsyncMap(@"set", @map, @key, @newVal, ret) = {
      new hashCh, bitListCh in {
        o!(["Hashing ", key]) |
        // Hash the key to get a 256-bit array
        @"keccak256Hash"!(key.toByteArray(), *hashCh) |
        for (@hash <- hashCh) {
          o!(["Got hash, converting to bits ", hash]) |
          // Get the bit list
          ByteArrayToBitList!(hash, 0, hash.length(), [], *bitListCh) |
          for (@bitList <- bitListCh) {
            o!(["Converted to bits, starting loop", bitList]) |
            AsyncMapSetter!(map, bitList, 0, bitList.length(), newVal, *ret)
          }
        }
      }
    } |
    
    // Usage
    new o(`rho:io:stdout`), mapCh in {
      o!("Initializing map") |
      AsyncMap!("init", *mapCh) |
      for (@map <- mapCh) {
        o!("Map initialized, setting") |
        new ret in {
          AsyncMap!("set", map, "some key", "some val", *ret) |
          for (_ <- ret) {
            o!("Value set, getting") |
            AsyncMap!("get", map, "some key", *ret) |
            for (@val <- ret) {
              o!(["Got this from the map: ", val])
            }
          }
        }
      }
    }
  }
}