// Rholang map desiderata: speedy insert & lookup,  no conflicts on lookup, no conflicts on inserts to different keys
// This implementation: O(log n) insert & lookup.
// Conflict analysis
//   Lookup
//     The cell implementation uses a linear for, and when two processes send
//     to the same linear for, you get a conflict. When looking up an item when
//     you don't know if it's in the map or not, it necessarily sends "get" to
//     the root cell of the map, so lookups of that kind conflict.  When
//     looking up an item where you know it's in the map, you can use
//     "fastUnsafeGet" and avoid the root cell.
//   Insert
//     As above, inserting necessarily sends a "get" to the root cell, thus
//     inserts conflict.

new AsyncMap, o(`rho:io:stdout`) in {
  new MakeCell, ByteArrayToNybbleList, AsyncMapSetter, AsyncMapGetter, powersCh in {
    powersCh!([1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768, 65536]) |
    for (@powers <- powersCh) {
      contract MakeCell(@val, cell) = {
        for (@cmd, @args <- cell) {
          match cmd {
            "get" => {
              match args {
                [ret] => {
                  @ret!(val) |
                  MakeCell!(val, *cell)
                }
                x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 16", x]) }
              }
            }
            "set" => {
              match args {
                [newVal, ret] => {
                  @ret!(Nil) |
                  MakeCell!(newVal, *cell)
                }
                x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 25", x]) }
              }
            }
            "setBit" => {
              match args {
                [bit, ret] => {
                  @ret!(Nil) |
                  MakeCell!(
                    // val | (1 << bit)
                    // Bitwise operators would be really nice to have!
                    (val % powers.nth(bit)) +
                      (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +
                      powers.nth(bit),
                    *cell
                  )
                }
                x => { o!(["ERROR: MATCH FAIL. MakeCell.get line 41", x]) }
              }
            }
            "die" => { Nil }
            x => { o!(["ERROR: MATCH FAIL. MakeCell line 45", x]) }
          }
        }
      } |

      contract ByteArrayToNybbleList(@ba, @n, @len, @acc, ret) = {
        if (n == len) {
          ret!(acc)
        } else {
          ByteArrayToNybbleList!(ba, n+1, len, acc ++ [ ba.nth(n) % 16, ba.nth(n) / 16 ], *ret)
        }
      } |

      contract AsyncMap(@"init", ret) = {
        new map in {
          MakeCell!(0, [*map, []]) |
          ret!(*map)
        }
      } |

      contract AsyncMapGetter(@map, @nybList, @n, @len, ret) = {
        o!(["In getter: ", nybList, n, len]) |
        // Look up the value of the cell at [map, nybList.slice(0, n + 1)]
        new valCh in {
          o!(["Getting from ", nybList.slice(0, n)]) |
          @[map, nybList.slice(0, n)]!("get", [*valCh]) |
          for (@val <- valCh) {
            o!(["Got ", val]) |
            if (n == len) {
              o!(["n == len, returning ", val]) |
              // If we're at the end of the path, return.
              ret!(val)
            } else {
              o!(["nybList.nth(n) = ", nybList.nth(n)]) |
              // Otherwise check if the rest of the path exists.
              // Bit k set means cell k exists.
              // nybList.nth(n) is the cell number
              // val & powers.nth(nybList.nth(n)) is nonzero if the cell exists
              // (val/powers.nth(nybList.nth(n))) % 2 is 1 if the cell exists
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                o!(["Cell missing"]) |
                ret!([])
              } else {
                o!(["Cell found, recursing"]) |
                AsyncMapGetter!(map, nybList, n + 1, len, *ret)
              }
            }
          }
        }
      } |

      contract AsyncMap(@"get", @map, @key, ret) = {
        new hashCh, nybListCh in {
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh) {
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, hash.length(), [], *nybListCh) |
            for (@nybList <- nybListCh) {
              AsyncMapGetter!(map, nybList.slice(0, 16), 0, 16, *ret)
            }
          }
        }
      } |

      // Doesn't walk the path, just tries to fetch it directly.
      // Will hang if there's no value there.
      contract AsyncMap(@"fastUnsafeGet", @map, @key, ret) = {
        new hashCh, nybListCh in {
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh) {
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, hash.length(), [], *nybListCh) |
            for (@nybList <- nybListCh) {
              @[map, nybList.slice(0, 16)]!("get", [*ret])
            }
          }
        }
      } |

      contract AsyncMapSetter(@map, @nybList, @n, @len, @newVal, ret) = {
        o!(["In loop: ", n, len]) |
        // Look up the value of the cell at [map, nybList.slice(0, n + 1)
        new valCh in {
          o!(["Getting slice", nybList.slice(0, n)]) |
          @[map, nybList.slice(0, n)]!("get", [*valCh]) |
          for (@val <- valCh) {
            o!(["Got val ", val]) |
            if (n == len) {
              // If we're at the end of the path, set the cell to newVal.
              o!(["Setting final cell to ", [newVal]]) |
              @[map, nybList]!("set", [[newVal], *ret])
            } else {
              // Otherwise make the rest of the path exist.
              // Bit k set means cell k exists.
              o!(["nybList.nth()", n, nybList.nth(n)]) |
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                // Cell missing
                // Create cell, set cell to 0
                MakeCell!(0, [map, nybList.slice(0, n + 1)]) |
                new ack in {
                  // Atomically update current cell to val | (1 << nybList.nth(n))
                  @[map, nybList.slice(0, n)]!("setBit", [nybList.nth(n), *ack]) |
                  for (_ <- ack) {
                    AsyncMapSetter!(map, nybList, n + 1, len, newVal, *ret)
                  }
                }
              } else {
                // Cell exists, loop
                AsyncMapSetter!(map, nybList, n + 1, len, newVal, *ret)
              }
            }
          }
        }
      } |

      contract AsyncMap(@"set", @map, @key, @newVal, ret) = {
        new hashCh, nybListCh in {
          o!(["Hashing ", key]) |
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh) {
            o!(["Got hash, converting to nybbles ", hash]) |
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, hash.length(), [], *nybListCh) |
            for (@nybList <- nybListCh) {
              o!(["Converted to nybbles, starting loop", nybList]) |
              AsyncMapSetter!(map, nybList.slice(0, 16), 0, 16, newVal, *ret)
            }
          }
        }
      } |

      // Usage
      new o(`rho:io:stdout`), mapCh in {
        o!("Initializing map") |
        AsyncMap!("init", *mapCh) |
        for (@map <- mapCh) {
          o!("Map initialized, setting") |
          new ret1, ret2 in {
            AsyncMap!("set", map, "some key", "some val", *ret1) |
            AsyncMap!("set", map, "monkey", "some other val", *ret2) |
            for (_ <- ret1; _ <- ret2) {
              o!("Value set, getting") |
              AsyncMap!("get", map, "some key", *ret1) |
              AsyncMap!("fastUnsafeGet", map, "monkey", *ret2) |
              for (@val1 <- ret1; @val2 <- ret2) {
                o!(["Got these from the map: ", val1, val2])
              }
            }
          }
        }
      }
    }
  }
}