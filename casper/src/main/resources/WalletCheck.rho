/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = 8efb9d149ffe4065f591e9428ee7eeeaa59d88426b721244b43f5e28e9f75349
 2.  |            | given              | timestamp = 1559156388100
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 04a3070d2f090e8015d2a34adcb4c82b8e21aa56f15a8dff2690d0c316e07bec8e393d1a218b581bc2025d435ff2c7151f7b04ee1e162a608f458d3bf8fb16908f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0x4ca8ca1cff2656b3a1f7765bf3819416ce6f9f9e44102229a2622c98cd65de22)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0x4ca8ca1cff2656b3a1f7765bf3819416ce6f9f9e44102229a2622c98cd65de22) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a204ca8ca1cff2656b3a1f7765bf3819416ce6f9f9e44102229a2622c98cd65de221001
 8.  | 7, 1,      | secp256k1          | sig = 3045022100bce7a465fcab95a5d2bcd27c99f9d6d912393ee7966dc46ec4ce60c80a382085022068c953950b87226c51267e90f8368f26457026d75e7ee54d4a4c447f785d4079
 9.  | 4,         | registry           | uri = rho:id:5ssrgy91wskd46gjjo6qamxhg88t1fymb5ekgzfksgyeubgq3nucc9
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new 
  WalletCheck, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), BasicWalletCh, claimContractStore,
  walletStore
in {
  rl!(`rho:lang:basicWallet`, *BasicWalletCh) |
  for(@(_, BasicWallet) <- BasicWalletCh) {
    claimContractStore!({}) |
    walletStore!({}) |
  
    // create: makes a wallet check
    //
    // string ethAddr: the address of the funds on Ethereum (pre-issuance)
    // Purse purse: the funds to put in the wallet
    contract WalletCheck(@"create", @ethAddr, @purse) = {
      new doneStore, claimContract in {
        doneStore!(false) |
        for(@claimContractMap <- claimContractStore) {
          claimContractStore!(claimContractMap.set(ethAddr, *claimContract))
        } |
        
        // claims the wallet by presenting the preimage of the hash
        //
        // string pubkey: Base16 encoded public key. It should be true that
        //                "0x" + Base16.encode(keccak256.hash(Base16.decode(pubkey)).takeRight(20)) == ethAddr
        // name statusOut
        // string sig: signature of [pubKey, statusOut]
        contract claimContract(@[pubKey, statusOut], @sig) = {
          
          // Make sure the purse hasn't already been claimed
          for (@done <- doneStore) {
            if (done) {
              doneStore!(done) |
              @statusOut!((false, "Already claimed wallet"))
            } else {

              // Verify signature 
              new verifiedOut, calcAddrOut, hashOut in {
                @"keccak256Hash"!([pubKey, statusOut].toByteArray(), *hashOut) |
                for(@dataHash <- hashOut) {
                  //need to verify the signature using the provided plue 1 extra byte (for some reason...)
                  @"secp256k1Verify"!(dataHash, sig.hexToBytes(), ("04" ++ pubKey).hexToBytes(), *verifiedOut) |
                  for (@verified <- verifiedOut) {
                    if (verified) {
                      // Check that given pubKey is the preimage of hash
                      WalletCheck!("publicToAddr", pubKey, *calcAddrOut) |
                      for (@calcAddr <- calcAddrOut) {
                        //drop the "0x" from the Ethereum address then convert to bytes
                        if (calcAddr == ethAddr.slice(2, ethAddr.length()).hexToBytes()) {
                          new walletOut in {

                            // Create the wallet
                            @BasicWallet!(purse, "secp256k1", "04" ++ pubKey, *walletOut) |

                            for (@[wallet] <- walletOut) {
                              //record the claimed wallet in the store for later retrieval
                              for(@wallets <- walletStore) {
                                walletStore!(wallets.set(pubKey, wallet))
                              } |
                            
                              // Return success
                              @statusOut!((true, "Success!"))
                            } |
                            
                            // All done
                            doneStore!(true)
                          }
                        } else {
                          doneStore!(done) |
                          @statusOut!((false, "Public key is not the preimage of hash"))
                        }
                      }
                    } else {
                      doneStore!(done) |
                      @statusOut!((false, "Signature verification failed"))
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    //computes the ethereum address from a public key
    //string pubKey
    //returns bytearray
    contract WalletCheck(@"publicToAddr", @pubKey, ret) = {
      new hashOut in {
        @"keccak256Hash"!(pubKey.hexToBytes(), *hashOut) |
        for(@pkHash <- hashOut) {
          ret!(pkHash.slice(12, 32))
        }
      }
    } |
    
    contract WalletCheck(@"claim", @ethAddr, @pubKey, @sig, statusOut) = {
      for(@claimContractMap <- claimContractStore) {
        claimContractStore!(claimContractMap) |
        match claimContractMap.get(ethAddr) {
          Nil           => { statusOut!((false, "Unknown Ethereum address")) }
          claimContract => { @claimContract!([pubKey, *statusOut], sig) }
        }
      }
    } |
    
    contract WalletCheck(@"access", @pubKey, return) = {
      for(@wallets <- walletStore) {
        walletStore!(wallets) |
        match wallets.get(pubKey) {
          Nil    => { return!((false, "Unknown wallet public key")) }
          wallet => { return!((true, wallet)) }
        }
      }
    }
  } |
  rs!(
    "04a3070d2f090e8015d2a34adcb4c82b8e21aa56f15a8dff2690d0c316e07bec8e393d1a218b581bc2025d435ff2c7151f7b04ee1e162a608f458d3bf8fb16908f".hexToBytes(),
    (9223372036854775807, bundle+{*WalletCheck}),
    "3045022100bce7a465fcab95a5d2bcd27c99f9d6d912393ee7966dc46ec4ce60c80a382085022068c953950b87226c51267e90f8368f26457026d75e7ee54d4a4c447f785d4079".hexToBytes(),
    *uriOut
  )
}
  
  
