 /*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = b07ab04ff922adc0fd7963e4a17759643a15e51ae8843053499c0d0ebc2cd869
 2.  |            | given              | timestamp = 1553607754230
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | ed25519            | pk = aca5cc65b4a7abbd558fb39dc3c2e9bf650ef91184529dcd856b6183dc64d8dc
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xed55dd92e8ae1950708fdfe1173a8809825a4f9a3464e96c6349d25093ce3284)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xed55dd92e8ae1950708fdfe1173a8809825a4f9a3464e96c6349d25093ce3284) })
 7.  | 6,         | protobuf           | toSign = 2a3eaa013b0a0d2a0b10feffffffffffffffff010a2a5a280a243a220a20ed55dd92e8ae1950708fdfe1173a8809825a4f9a3464e96c6349d25093ce32841001
 8.  | 7, 1,      | ed25519            | sig = 974936757967d4d6aecc4b6e107485deab9a6f7e68a8fc9a39e2fb6317113d79d90647626b6affabb99d6a3178d1a4dc596bb636a524667d838ef34463af6b08
 9.  | 4,         | registry           | uri = rho:id:4njqcsc65mt8xrfx9nsz7je7oucgywgd1tj1n1gjtw3ndsophyisro
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new
  AuthKey,
  rs(`rho:registry:insertSigned:ed25519`),
  uriOut,
  getDeployData(`rho:deploy:params`),
  _authKey,
  stdout(`rho:io:stdout`)
in {

  contract AuthKey(@"make", @shape, ret) = {
    new authKey in {

      // We could make the key 'usable once' by changing this to a single (vs persistent) receive
      // and returning the response along with a nonce, created inside the "challenge" method.
      contract authKey(@"challenge", retCh) = {
        retCh!(bundle0{ (*_authKey, shape)})
      } |

      ret ! (bundle+{*authKey})
    }
  } |

  contract AuthKey(@"check", key, @shape, ret) = {
    new responseCh in {
      key!("challenge", *responseCh) |
      for (@response <- responseCh) {
        ret!(response == { bundle0{ (*_authKey, shape) } } )
      }
    }
  } |

  rs!(
    "aca5cc65b4a7abbd558fb39dc3c2e9bf650ef91184529dcd856b6183dc64d8dc".hexToBytes(),
    (9223372036854775807, bundle+{*AuthKey}),
    "974936757967d4d6aecc4b6e107485deab9a6f7e68a8fc9a39e2fb6317113d79d90647626b6affabb99d6a3178d1a4dc596bb636a524667d838ef34463af6b08".hexToBytes(),
    *uriOut
  )
}

