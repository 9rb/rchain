/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = b97f282ce7d7d83c1abb5aa8f544e84f25bd96d75b6cb990b9b6ea2a1fc260f0
 2.  |            | given              | timestamp = 1559156113243
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 043b9a8358561912d2dd0fc94b5c6c01dce2b97c91b34f698aa3dabbefd5c6fd5c4ac2d5db0232545d44de1ee66e1f4828bbb0933e2227c3a6240429f0ef47c233
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xc274979cec5d4e0f9f6ef7b7c1236254b1eeb8869f0dad6df87649a9660c58f9)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xc274979cec5d4e0f9f6ef7b7c1236254b1eeb8869f0dad6df87649a9660c58f9) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20c274979cec5d4e0f9f6ef7b7c1236254b1eeb8869f0dad6df87649a9660c58f91001
 8.  | 7, 1,      | secp256k1          | sig = 304402203501600daa0f184741370b76858a6b96aaceedf602a74636b5c30eb6f8c8432402200c18f0c6eaca0765674573731b5548d649a6b3fc3dc0480d3f377877fb5bcde5
 9.  | 4,         | registry           | uri = rho:id:3m6iwxy7kq4wdhw4hsm5qghdxckduxtfnzgj86zy1mht3a7dsyxcuf
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new 
  BasicWallet, rs(`rho:registry:insertSigned:secp256k1`), uriOut
in {
  contract BasicWallet(purse, @algorithm, @pk, return) = {
    new cryptoVerifyCh in {
      match algorithm {
        "ed25519" => {
          cryptoVerifyCh!(["ed25519Verify"])
        }
        "secp256k1" => {
          cryptoVerifyCh!(["secp256k1Verify"])
        }
        _ => {
          cryptoVerifyCh!([])
        }
      } |
      for(@maybeCryptoVerify <- cryptoVerifyCh) {
        match maybeCryptoVerify {
          []             => { return!([]) }
          [cryptoVerify] => {
            new basicWallet, verify, nonceCh in {
              nonceCh!(-1) |
              contract verify(@nonce, @amount, @retCh, @sig, return) = {
                for(@prevNonce <- nonceCh) {
                  if (nonce == (prevNonce + 1)) {
                    new result, hashOut in {
                      @"blake2b256Hash"!([nonce, amount, retCh].toByteArray(), *hashOut) |
                      for(@hash <- hashOut) {
                        @cryptoVerify!(hash, sig.hexToBytes(), pk.hexToBytes(), *result) |
                        for(@r <- result) {
                          if (r) { nonceCh!(nonce) | return!(true) }
                          else { nonceCh!(prevNonce) | return!(false) }
                        }
                      }
                    }
                  } else {
                    nonceCh!(prevNonce) | return!(false)
                  }
                }
              } |
              contract basicWallet(@"getNonce", return) = {
                for(@nonce <- nonceCh) {
                  nonceCh!(nonce) | return!(nonce)
                }
              } |
              contract basicWallet(@"getBalance", return) = {
                purse!("getBalance", *return)
              } |
              contract basicWallet(@"deposit", @amount, @src, success) = {
                purse!("deposit", amount, src, *success)
              } |
              contract basicWallet(@"transfer", @amount, @nonce, @sig, destination, status) = {
                new verifyResult in {
                  verify!(nonce, amount, *destination, sig, *verifyResult) | for(@verified <- verifyResult) {
                    if (verified) { 
                      new splitResultCh in {
                        purse!("split", amount, *splitResultCh) |
                        for(@splitResult  <- splitResultCh) {
                          match splitResult {
                            []        => { status!("Overdraft") }
                            [payment] => { destination!(payment) | status!("Success") }
                          }
                        }
                      }
                    } else { status!("Invalid signature or nonce") }
                  }
                }
              } |
              return!([bundle+{*basicWallet}])
            }
          }
        }
      }
    }
  } |
  rs!(
    "043b9a8358561912d2dd0fc94b5c6c01dce2b97c91b34f698aa3dabbefd5c6fd5c4ac2d5db0232545d44de1ee66e1f4828bbb0933e2227c3a6240429f0ef47c233".hexToBytes(),
    (9223372036854775807, bundle+{*BasicWallet}),
    "304402203501600daa0f184741370b76858a6b96aaceedf602a74636b5c30eb6f8c8432402200c18f0c6eaca0765674573731b5548d649a6b3fc3dc0480d3f377877fb5bcde5".hexToBytes(),
    *uriOut
  )
}
  
  
