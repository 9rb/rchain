/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = 634e0c91a56a94c6b876af8c8d0682dfcbe96b3b8f4d87fea06d72fd9eea635c
 2.  |            | given              | timestamp = 1566323852884
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 040d9b9a04a7574bfbbce95eaa7bccb8e63bb4bffb617be2dfcd0bcee7d744f8b34a967c28fb5c6c497923c7d2385eb14a45c42378720235eace46a2ce949784bf
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xd57718c311ee536be37e9d706bfa39c554434b8a47056ead4aae0885f455e0a0)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xd57718c311ee536be37e9d706bfa39c554434b8a47056ead4aae0885f455e0a0) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20d57718c311ee536be37e9d706bfa39c554434b8a47056ead4aae0885f455e0a01001
 8.  | 7, 1,      | secp256k1          | sig = 3045022100c0e13111ecf63bc33f022f72b35498be9fec98939057ace3446ec96a52aca8ab0220330f5c89a4afe68309f32d67df1337a3b63dab3c6d6c1ed4e93bfb3c1ef4bc3f
 9.  | 4,         | registry           | uri = rho:id:9nw585aaqszdai4k9qdh88ysoy1hqddacyhunrs93t9qeuedo9m8ja
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */

// Rholang map desiderata: speedy insert & lookup,  no conflicts on lookup, no conflicts on inserts to different keys
// This implementation: O(log n) insert & lookup; also provides O(1) lookup when it is known that the value at a key exists.
// Conflict analysis, once peek has been implemented
//   Lookup
//     When looking up a value, only peeks are used, so lookups will not conflict.
//   Insert
//     When inserting, only peeks are used on existing cells (except the last
//     shared one in the path), while newly created cells have a different name.
//     So there's conflict only if the keys share a common prefix that hadn't
//     already been populated.
// Usage
// new o(`rho:io:stdout`), mapCh in {
//   o!("Initializing map") |
//   // Use 3 * 8 = 24 bits of parallelization
//   AsyncMap!("init", 3, *mapCh) |
//   for (@map <- mapCh) {
//     o!("Map initialized, setting") |
//     new ret1, ret2, ret3 in {
//       AsyncMap!("set", map, "some key", "some val", *ret1) |
//       AsyncMap!("set", map, "monkey", "some other val", *ret2) |
//       for (_ <- ret1; _ <- ret2) {
//         o!("Value set, getting") |
//         AsyncMap!("get", map, "some key", *ret1) |
//         AsyncMap!("fastUnsafeGet", map, "monkey", *ret2) |
//         AsyncMap!("get", map, "some unused key", *ret3) |
//         for (@val1 <- ret1; @val2 <- ret2; @val3 <- ret3) {
//           // Should print ["Got these from the map: ", ["some val"], ["some other val"], []]
//           o!(["Got these from the map: ", val1, val2, val3])
//         }
//       }
//     }
//   }
// }

new AsyncMap, rs(`rho:registry:insertSigned:secp256k1`), uriOut in {
  new MakeCell, ByteArrayToNybbleList, AsyncMapSetter, AsyncMapGetter, powersCh in {
    powersCh!([1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536]) |
    for (@powers <- powersCh) {
      contract MakeCell(@initVal, cell) = {
        new cellStore in {
          cellStore!(initVal) |
          contract cell(@"get", ret) = {
            // TODO: convert to peek
            for (@val <- cellStore) {
              cellStore!(val) |
              ret!(val)
            }
          } |
          
          contract cell(@"set", @newVal, ack) = {
            for (_ <- cellStore) {
              cellStore!(newVal) |
              ack!(Nil)
            }
          } |
          
          contract cell(@"setBit", @bit, ack) = {
            for (@val <- cellStore) {
              // val | (1 << bit)
              // Bitwise operators would be really nice to have!
              cellStore!((val % powers.nth(bit)) +
                (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +
                powers.nth(bit)) |
              ack!(Nil)
            }
          } |
          
          contract cell(@"setMap", @newKey, @newVal, ack) = {
            for (@val <- cellStore) {
              ack!(Nil) |
              if (val == 0) { cellStore!({newKey: newVal}) }
              else { cellStore!(val.set(newKey, newVal)) }
            }
          }
        }
      } |

      contract ByteArrayToNybbleList(@ba, @n, @len, @acc, ret) = {
        if (n == len) {
          ret!(acc)
        } else {
          ByteArrayToNybbleList!(ba, n+1, len, acc ++ [ ba.nth(n) % 16, ba.nth(n) / 16 ], *ret)
        }
      } |

      contract AsyncMap(@"init", @depth, ret) = {
        new map in {
          MakeCell!(0, (*map, [])) |
          @(*map, "depth")!!(depth) |
          ret!(*map)
        }
      } |

      contract AsyncMapGetter(@map, @nybList, @n, @len, @suffix, ret) = {
        // Look up the value of the cell at [map, nybList.slice(0, n + 1)]
        new valCh, restCh in {
          @(map, nybList.slice(0, n))!("get", *valCh) |
          for (@val <- valCh) {
            if (n == len) {
              restCh!(val.get(suffix)) |
              for (@rest <- restCh) {
                if (rest == Nil) { ret!([]) }
                else { ret!(rest) }
              }
            } else {
              // Otherwise check if the rest of the path exists.
              // Bit k set means cell k exists.
              // nybList.nth(n) is the cell number
              // val & powers.nth(nybList.nth(n)) is nonzero if the cell exists
              // (val/powers.nth(nybList.nth(n))) % 2 is 1 if the cell exists
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                ret!([])
              } else {
                AsyncMapGetter!(map, nybList, n + 1, len, suffix, *ret)
              }
            }
          }
        }
      } |

      contract AsyncMap(@"get", @map, @key, ret) = {
        new hashCh, nybListCh in {
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh; @depth <- @(map, "depth")) {
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
            for (@nybList <- nybListCh) {
              AsyncMapGetter!(map, nybList, 0, 2 * depth, hash.slice(depth, 32), *ret)
            }
          }
        }
      } |

      // Doesn't walk the path, just tries to fetch it directly.
      // Will hang if there's no key with that 64-bit prefix.
      // Returns [] like "get" does if there is some other key with
      // the same prefix but no value there.
      contract AsyncMap(@"fastUnsafeGet", @map, @key, ret) = {
        new hashCh, nybListCh in {
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh; @depth <- @(map, "depth")) {
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
            for (@nybList <- nybListCh) {
              new restCh, valCh in {
                @(map, nybList)!("get", *restCh) |
                for (@rest <- restCh) {
                  valCh!(rest.get(hash.slice(depth, 32))) |
                  for (@val <- valCh) {
                    if (val == Nil) { ret!([]) }
                    else { ret!(val) }
                  }
                }
              }
            }
          }
        }
      } |

      contract AsyncMapSetter(@map, @nybList, @n, @len, @newVal, @suffix, ret) = {
        // Look up the value of the cell at [map, nybList.slice(0, n + 1)
        new valCh, restCh in {
          @(map, nybList.slice(0, n))!("get", *valCh) |
          for (@val <- valCh) {
            if (n == len) {
              // If we're at the end of the path, set the cell to newVal.
              @(map, nybList)!("setMap", suffix, [newVal], *ret)
            } else {
              // Otherwise make the rest of the path exist.
              // Bit k set means cell k exists.
              if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {
                // Cell missing
                // Create cell, set cell to 0
                MakeCell!(0, (map, nybList.slice(0, n + 1))) |
                new ack in {
                  // Atomically update current cell to val | (1 << nybList.nth(n))
                  @(map, nybList.slice(0, n))!("setBit", nybList.nth(n), *ack) |
                  for (_ <- ack) {
                    AsyncMapSetter!(map, nybList, n + 1, len, newVal, suffix, *ret)
                  }
                }
              } else {
                // Cell exists, loop
                AsyncMapSetter!(map, nybList, n + 1, len, newVal, suffix, *ret)
              }
            }
          }
        }
      } |

      contract AsyncMap(@"set", @map, @key, @newVal, ret) = {
        new hashCh, nybListCh in {
          // Hash the key to get a 256-bit array
          @"keccak256Hash"!(key.toByteArray(), *hashCh) |
          for (@hash <- hashCh; @depth <- @(map, "depth")) {
            // Get the bit list
            ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |
            for (@nybList <- nybListCh) {
              AsyncMapSetter!(map, nybList, 0, 2 * depth, newVal, hash.slice(depth, 32), *ret)
            }
          }
        }
      }
    }
  } |
  rs!(
    "040d9b9a04a7574bfbbce95eaa7bccb8e63bb4bffb617be2dfcd0bcee7d744f8b34a967c28fb5c6c497923c7d2385eb14a45c42378720235eace46a2ce949784bf".hexToBytes(),
    (9223372036854775807, bundle+{*AsyncMap}),
    "3045022100c0e13111ecf63bc33f022f72b35498be9fec98939057ace3446ec96a52aca8ab0220330f5c89a4afe68309f32d67df1337a3b63dab3c6d6c1ed4e93bfb3c1ef4bc3f".hexToBytes(),
    *uriOut
  )
}
