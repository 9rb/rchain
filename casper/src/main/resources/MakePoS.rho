/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a06e7e66a0f57baed75f35770b6e6496b4d556d7fa7fb94b7f9d275a26805d04
 2.  |            | given              | timestamp = 1559156284416
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 04990b358a69aa4e36dd8811f010416ffb09bd53d3c5fa8bc91a585a88e161fb299d241c6a7dd977bf9017ef507bf965d0aa4a12919d521775407c3830c59974c7
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xeb58132e9b06ccc10a037ec292c37b76c39841f8b9a25dcc0ad76c592fa78b7f)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xeb58132e9b06ccc10a037ec292c37b76c39841f8b9a25dcc0ad76c592fa78b7f) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20eb58132e9b06ccc10a037ec292c37b76c39841f8b9a25dcc0ad76c592fa78b7f1001
 8.  | 7, 1,      | secp256k1          | sig = 30440220443b960fc554055f0df7eca5d2974b6e3be74a2cc85a6bb15bf5fadcbc1661a602200a441d891c5bef727119e1f9dc0c28dda79facabe31a70a5e2c0935ab98032d8
 9.  | 4,         | registry           | uri = rho:id:ko5q4wr5qu4a54cynf44hbk7hbzawpa4qxigzo7rc157rjqhwuo4mt
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */
new 
  MakePoS, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), ListOpsCh, EitherCh
in {
  rl!(`rho:lang:listOps`, *ListOpsCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  for(@(_, ListOps) <- ListOpsCh; @(_, Either) <- EitherCh) {
    contract MakePoS(purse, @minimumBond, @maximumBond, @initBonds, return) = {
      new 
        this, bondsCh, clonePurse, depositPurse,
        updateBonds, paymentStore
      in {
        bondsCh!(initBonds) |

        //The purpose of this contract is to move the contents
        //of an existing purse into a new purse. This prevents
        //the owner of the given purse from modifying the balance
        //during processing.
        contract clonePurse(givenPurse, return) = {
          new balanceCh, resultCh in {
            givenPurse!("getBalance", *balanceCh) |
            for(@balance <- balanceCh) {
              givenPurse!("split", balance, *resultCh) |
              for(@result <- resultCh) {
                match result {
                  [] => { return!((false, "Could not extract funds from given purse")) }
                  [newPurse] => { return!((true, (newPurse, balance))) }
                }
              }
            }
          }
        } |
      
        contract this(@"validateBondAmount", @bondPurse, return) = {
          new balanceCh in {
            @bondPurse!("getBalance", *balanceCh) |
            for(@balance <- balanceCh) {
              if      (balance < minimumBond) { return!((false, "Bond less than minimum!")) }
              else if (balance > maximumBond) { return!((false, "Bond greater than maximum!")) }
              else                                         { return!((true, bondPurse)) }
            }
          }
        } |

        contract this(@"validateBondingRate", @bondPurse, return) = {
          //TODO: figure out rate-limiting of bonding
          return!((true, bondPurse))
        } |
        
        contract depositPurse(@bondPurse, @amount, return) = {
          new successCh in {
            purse!("deposit", amount, bondPurse, *successCh) |
            for(@success <- successCh) {
              if (success) { return!((true, bondPurse)) }
              else         { return!((false, "Deposit failed.")) }
            }
          }
        } |
        
        contract this(@"isBonded", @publicKey, return) = {
          for(@bonds <- bondsCh) {
            bondsCh!(bonds) | return!(bonds.contains(publicKey))
          }
        } |
        
        contract this(@"getBonds", return) = {
          for(@bonds <- bondsCh) {
            bondsCh!(bonds) | return!(bonds)
          }
        } |

        contract updateBonds(@publicKey, @sigVerify, @bondAmount, @rewardsForwarder, return) = {
          for(@bonds <- bondsCh) {
            bondsCh!(bonds.set(publicKey, (bondAmount, sigVerify, rewardsForwarder, bonds.size() + 1))) |
            return!((true, "Bond successful!"))
          }
        } |

        contract this(@"bond", @publicKey, @sigVerify, @givenBondPurse, @rewardsForwarder, return) = {
          //TODO: Validate that givenBondPurse comes from the same mint as purse

          new
            resultCh, bondPurseCh, validatePublicKey, depositClonePurse,
            validateBondAmount, validateBondingRate
          in {
            //lambda-expression-like construction to insert key validation into the composition
            for(@x, ret <- validatePublicKey){
              new isBondedCh in {
                this!("isBonded", publicKey, *isBondedCh) |
                for(@isBonded <- isBondedCh) {
                  if (isBonded) { ret!((false, "Public key ${pk} already bonded." %% {"pk" : publicKey})) }
                  else          { ret!((true, x)) }
                }
              }
            } |
            for(@bp, ret <- validateBondAmount) {
              this!("validateBondAmount", bp, *ret)
            } |
            for(@bp, ret <- validateBondingRate) {
              this!("validateBondingRate", bp, *ret)
            } |
            clonePurse!(givenBondPurse, *bondPurseCh) |
            for(@cloneResult <- bondPurseCh) {
              match cloneResult {
                (true, (bondPurse, bondAmount)) => {
                  for(_, ret <- depositClonePurse) {
                    depositPurse!(bondPurse, bondAmount, *ret)
                  } |
                  @Either!("compose", bondPurse, [
                                        *validateBondAmount, 
                                        *validateBondingRate,
                                        *validatePublicKey,
                                        *depositClonePurse
                                        ], *resultCh) |
                  for(@result <- resultCh) {
                    match result {
                      (true, _) => { updateBonds!(publicKey, sigVerify, bondAmount, rewardsForwarder, *return) }

                      (false, message) => {
                        //return funds to original purse since an error occurred
                        @givenBondPurse!("deposit", bondAmount, bondPurse, *resultCh) |
                        for(_ <- resultCh) { return!((false, message)) }
                      }
                    }
                  }
                }
                (false, message) => { return!((false, message)) }
              }
            }
          }
        } |
      
        //TODO: Fill in this contract (RHOL-462)
        contract this(@"distribute", @purse) = {
          Nil
        } |
      
        paymentStore!((Nil, Nil, Nil, Nil)) |
      
        //Make it easy to query the last payment so that validators
        //can check how much phlo there is for the deploy.
        contract this(@"lastPayment", return) = {
          for(@payment <- paymentStore) {
            paymentStore!(payment) |
            return!(payment)
          }
        } |
      
        //This is the contract that deploy payment code ultimately needs
        //to call in order to pay for the deploy.
        contract this(@"pay", @purse, return) = {
          new payPurseCh, p(`rho:deploy:params`), paramsCh in {
            clonePurse!(purse, *payPurseCh) |
            p!(*paramsCh) |
            for(
              @cloneResult <- payPurseCh;
              @codeHash, @phloRate, @userId, @timestamp <- paramsCh
            ) {
              match cloneResult {
                (true, (payPurse, payAmount)) => {
                  this!("distribute", payPurse) | //distribute rev paid to validators
                  //update paymentStore
                  for(_ <- paymentStore){ paymentStore!((codeHash, userId, timestamp, phloRate * payAmount)) } |
                  return!(phloRate * payAmount) //return amount of phlo purchased to user (in case they care)
                }
                (false, message) => {
                  for(_ <- paymentStore){ paymentStore!((codeHash, userId, timestamp, 0)) } |
                  return!(0)
                }
              }
            }
          }
        } |
      
        return!(bundle+{*this})
      }
    }
  } |
  rs!(
    "04990b358a69aa4e36dd8811f010416ffb09bd53d3c5fa8bc91a585a88e161fb299d241c6a7dd977bf9017ef507bf965d0aa4a12919d521775407c3830c59974c7".hexToBytes(),
    (9223372036854775807, bundle+{*MakePoS}),
    "30440220443b960fc554055f0df7eca5d2974b6e3be74a2cc85a6bb15bf5fadcbc1661a602200a441d891c5bef727119e1f9dc0c28dda79facabe31a70a5e2c0935ab98032d8".hexToBytes(),
    *uriOut
  )
}
  
  
