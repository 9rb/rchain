contract @"MakePoS"(@purse, @minimumBond, @maximumBond, @initBonds, return) = {
  new this, bondsCh, clonePurse, depositPurse in {
    bondsCh!(initBonds) |
  
    //The purpose of this contract is to move the contents
    //of an existing purse into a new purse. This prevents
    //the owner of the given purse from modifying the balance
    //during processing.
    contract clonePurse(@givenPurse, return) = {
      new balanceCh, resultCh in {
        @[givenPurse, "getBalance"]!(*balanceCh) |
        for(@balance <- balanceCh) {
          @[givenPurse, "split"]!(balance, *resultCh) |
          for(@result <- resultCh) {
            match result {
              [] => { return!(("Left", "Could not extract funds from given purse")) }
              [newPurse] => { return!(("Right", (newPurse, balance))) }
            }
          }
        }
      }
    } |
  
    contract @[*this, "validateBondAmount"](@bondPurse, return) = {
      new balanceCh in {
        @[bondPurse, "getBalance"]!(*balanceCh) |
        for(@balance <- balanceCh) {
          if      (balance < minimumBond) { return!(("Left", "Bond less than minimum!")) }
          else if (balance > maximumBond) { return!(("Left", "Bond greater than maximum!")) }
          else                            { return!(("Right", bondPurse)) }
        }
      }
    } |

    contract @[*this, "validateBondingRate"](@bondPurse, return) = {
      //TODO: figure out rate-limiting of bonding
      return!(("Right", bondPurse))
    } |
    
    contract depositPurse(@bondPurse, return) = {
      new balanceCh, successCh in {
        @[bondPurse, "getBalance"]!(*balanceCh) |
        for(@balance <- balanceCh) {
          @[purse, "deposit"]!(balance, bondPurse, *successCh) |
          for(@success <- successCh) {
            if (success) { return!(("Right", balance)) }
            else         { return!(("Left", "Deposit failed.")) }
          }
        }
      }
    } |
    
    contract @[*this, "isBonded"](@publicKey, return) = {
      for(@bonds <- bondsCh) {
        bondsCh!(bonds) | return!(bonds.contains(publicKey))
      }
    } |
    
    contract @[*this, "getBonds"](return) = {
      for(@bonds <- bondsCh) {
        bondsCh!(bonds) | return!(bonds)
      }
    } |
    
    contract @[*this, "bond"](@publicKey, @sigVerify, @givenBondPurse, @rewardsForwarder, return) = {
      new resultCh, bondPurseCh, validatePublicKey in {
        //lambda-expression-like construction to insert key validation into the composition
        for(@x, ret <- validatePublicKey){
          new isBondedCh in {
            @[*this, "isBonded"]!(publicKey, *isBondedCh) |
            for(@isBonded <- isBondedCh) {
              if (isBonded) { ret!(("Left", "Public key ${pk} already bonded." %% {"pk" : publicKey})) }
              else          { ret!(("Right", x)) }
            }
          }
        } |
        clonePurse!(givenBondPurse, *bondPurseCh) |
        for(@cloneResult <- bondPurseCh) {
          match cloneResult {
            ("Right", (bondPurse, bondAmount)) => {
              @["Either", "compose"]!(bondPurse, [
                                    [*this, "validateBondAmount"], 
                                    [*this, "validateBondingRate"],
                                    *validatePublicKey,
                                    *depositPurse
                                    ], *resultCh) |
              for(@result <- resultCh) {
                match result {
                  ("Right", _) => {
                    for(@bonds <- bondsCh) {
                      bondsCh!(bonds.set(publicKey, (bondAmount, sigVerify, rewardsForwarder))) |
                      return!((true, "Bond successful!"))
                    }
                  }
                  ("Left", message) => {
                    //return funds to original purse since an error occurred
                    @[givenBondPurse, "deposit"]!(bondAmount, bondPurse, *resultCh) |
                    for(_ <- resultCh) { return!((false, message)) }
                  }
                }
              }
            }
            ("Left", message) => { return!((false, message)) }
          }
        }
      }
    } |
  
    return!(*this)
  }
}
